

#include "main.h"
/************************** Constant Definitions **************************/

/************************** Function Prototypes *****************************/
int Uart_Intr_Initialize(INTC *IntcInstPtr, XUartPs *UartInstPtr,
		u16 DeviceId, u16 UartIntrId);

int Uart_polled_Initialize(XUartPs *UartInstPtr,u16 DeviceId);

static int SetupInterruptSystem(INTC *IntcInstancePtr,
				XUartPs *UartInstancePtr,
				u16 UartIntrId);

void Handler(void *CallBackRef, u32 Event, unsigned int EventData);

/************************** Variable Definitions ***************************/
XUartPs Uart_Ps;		/* The instance of the UART Driver */
INTC InterruptController;	/* Instance of the Interrupt Controller */

static u8 SendBuffer[60];	/* Buffer for Transmitting Data */
static u8 RecvBuffer[60];	/* Buffer for Receiving Data */

volatile int TotalReceivedCount;
volatile int TotalSentCount;
int TotalErrorCount;
int new_EventCount;
int last_EventCount;
int temp_EventCount;

int Uart_polled_Initialize(XUartPs *UartInstPtr,u16 DeviceId)
{
	int Status;
	XUartPs_Config *Config;

	/*
	 * Initialize the UART driver so that it's ready to use
	 * Look up the configuration in the config table and then initialize it.
	 */
	Config = XUartPs_LookupConfig(DeviceId);
	if (NULL == Config) {
		return XST_FAILURE;
	}

	Status = XUartPs_CfgInitialize(UartInstPtr, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	XUartPs_SetBaudRate(UartInstPtr, 100000);

	return Status;

}
int Uart_Intr_Initialize(INTC *IntcInstPtr, XUartPs *UartInstPtr,
		u16 DeviceId, u16 UartIntrId)
{
	XUartPs_Config *Config;
	int Index;
	int Status;
	u32 IntrMask;
	int BadByteCount = 0;
	/*
	 * Initialize the UART driver so that it's ready to use
	 * Look up the configuration in the config table and then initialize it.
	 */
	Config = XUartPs_LookupConfig(DeviceId);
	if (NULL == Config) {
		return XST_FAILURE;
	}

	Status = XUartPs_CfgInitialize(UartInstPtr, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}



	Status = SetupInterruptSystem(IntcInstPtr, UartInstPtr, UartIntrId);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Setup the handlers for the UART that will be called from the
	 * interrupt context when data has been sent and received, specify
	 * a pointer to the UART driver instance as the callback reference
	 * so the handlers are able to access the instance data
	 */
	XUartPs_SetHandler(UartInstPtr, (XUartPs_Handler)Handler, UartInstPtr);

	/*
	 * Enable the interrupt of the UART so interrupts will occur, setup
	 * a local loopback so data that is sent will be received.
	 */
	IntrMask = //XUARTPS_IXR_RXOVR | XUARTPS_IXR_RXFULL;
		XUARTPS_IXR_TOUT | XUARTPS_IXR_PARITY | XUARTPS_IXR_FRAMING |
		XUARTPS_IXR_OVER | XUARTPS_IXR_TXEMPTY | XUARTPS_IXR_RXFULL |
		XUARTPS_IXR_RXOVR;

	if (UartInstPtr->Platform == XPLAT_ZYNQ_ULTRA_MP) {
		IntrMask |= XUARTPS_IXR_RBRK;
	}

	XUartPs_SetInterruptMask(UartInstPtr, IntrMask);

	XUartPs_SetOperMode(UartInstPtr, XUARTPS_OPER_MODE_NORMAL);
	/*
	* Set the receiver timeout. If it is not set, and the last few bytes
	* of data do not trigger the over-water or full interrupt, the bytes
	* will not be received. By default it is disabled.
	*
	* The setting of 8 will timeout after 8 x 4 = 32 character times.
	* Increase the time out value if baud rate is high, decrease it if
	* baud rate is low.
	*/
	//XUartPs_SetRecvTimeout(UartInstPtr, 32);

	for (Index = 0; Index < 60; Index++) {

		SendBuffer[Index] = (Index % 26) + 'A';
		RecvBuffer[Index] = 0;
	}

	XUartPs_Recv(UartInstPtr, RecvBuffer, 30);

	XUartPs_SetOperMode(UartInstPtr, XUARTPS_OPER_MODE_NORMAL);

	//XUartPs_SetBaudRate(UartInstPtr, 100000);   //用于采集遥控器DBUS数据
	xil_printf("begin!!!\r\n");
	 Xil_ExceptionEnable();
	/* If any bytes were not correct, return an error */
	if (BadByteCount != 0) {
		return XST_FAILURE;
	}

	return Status;
}

/**************************************************************************/
/**
*
* This function is the handler which performs processing to handle data events
* from the device.  It is called from an interrupt context. so the amount of
* processing should be minimal.
*
* This handler provides an example of how to handle data for the device and
* is application specific.
*
* @param	CallBackRef contains a callback reference from the driver,
*		in this case it is the instance pointer for the XUartPs driver.
* @param	Event contains the specific kind of event that has occurred.
* @param	EventData contains the number of bytes sent or received for sent
*		and receive events.
*
* @return	None.
*
* @note		None.
*
***************************************************************************/
void Handler(void *CallBackRef, u32 Event, unsigned int EventData)
{
	static index;
	/* All of the data has been sent */
	if (Event == XUARTPS_EVENT_SENT_DATA) {
		TotalSentCount = EventData;
		xil_printf("All of the data has been sent!!!\r\n");
	}

	/* All of the data has been received */
	if (Event == XUARTPS_EVENT_RECV_DATA) {
		TotalReceivedCount = EventData;

		xil_printf("All of the data has been received!!!\r\n");
		printf("EventData= %d  \r\n",EventData);
	}

	/*
	 * Data was received, but not the expected number of bytes, a
	 * timeout just indicates the data stopped for 8 character times
	 */
	if (Event == XUARTPS_EVENT_RECV_TOUT) {
		TotalReceivedCount = EventData;

		last_EventCount = new_EventCount;
		new_EventCount = EventData;
		temp_EventCount = new_EventCount - last_EventCount;

		xil_printf("XUARTPS_EVENT_RECV_TOUT!!!\r\n");
		printf("EventData= %d  \r\n",temp_EventCount);
/*	    printf("%d %d %d %d %d %d %d %d %d %d\r\n",RecvBuffer[0],RecvBuffer[1],\
	    											RecvBuffer[2],RecvBuffer[3],\
													RecvBuffer[4],RecvBuffer[5],\
													RecvBuffer[6],RecvBuffer[7],\
													RecvBuffer[8],RecvBuffer[9],\
													RecvBuffer[10]);
*/
	    //EventData=0;
	}

	/*
	 * Data was received with an error, keep the data but determine
	 * what kind of errors occurred
	 */
	if (Event == XUARTPS_EVENT_RECV_ERROR) {
		TotalReceivedCount = EventData;
		TotalErrorCount++;
		xil_printf("XUARTPS_EVENT_RECV_ERROR!!!\r\n");
		printf("EventData= %d  TotalErrorCount= %d\r\n",temp_EventCount,TotalErrorCount);
/*	    printf("%d %d %d %d %d %d %d %d %d %d\r\n",RecvBuffer[0],RecvBuffer[1],\
	    											RecvBuffer[2],RecvBuffer[3],\
													RecvBuffer[4],RecvBuffer[5],\
													RecvBuffer[6],RecvBuffer[7],\
													RecvBuffer[8],RecvBuffer[9],\
													RecvBuffer[10]);
	*/
	}


	/*
	 * Data was received with an parity or frame or break error, keep the data
	 * but determine what kind of errors occurred. Specific to Zynq Ultrascale+
	 * MP.
	 */
	if (Event == XUARTPS_EVENT_PARE_FRAME_BRKE) {
		TotalReceivedCount = EventData;
		TotalErrorCount++;
		xil_printf("XUARTPS_EVENT_PARE_FRAME_BRKE!!!\r\n");
	}

	/*
	 * Data was received with an overrun error, keep the data but determine
	 * what kind of errors occurred. Specific to Zynq Ultrascale+ MP.
	 */
	if (Event == XUARTPS_EVENT_RECV_ORERR) {
		TotalReceivedCount = EventData;
		TotalErrorCount++;
		xil_printf("XUARTPS_EVENT_RECV_ORERR!!!\r\n");
	}
}


/*****************************************************************************/
/**
*
* This function sets up the interrupt system so interrupts can occur for the
* Uart. This function is application-specific. The user should modify this
* function to fit the application.
*
* @param	IntcInstancePtr is a pointer to the instance of the INTC.
* @param	UartInstancePtr contains a pointer to the instance of the UART
*		driver which is going to be connected to the interrupt
*		controller.
* @param	UartIntrId is the interrupt Id and is typically
*		XPAR_<UARTPS_instance>_INTR value from xparameters.h.
*
* @return	XST_SUCCESS if successful, otherwise XST_FAILURE.
*
* @note		None.
*
****************************************************************************/
static int SetupInterruptSystem(INTC *IntcInstancePtr,
				XUartPs *UartInstancePtr,
				u16 UartIntrId)
{
	int Status;
	XScuGic_Config *IntcConfig; //Config for interrupt controller

	// Initialize the interrupt controller driver
	IntcConfig = XScuGic_LookupConfig(INTC_DEVICE_ID);
	if (NULL == IntcConfig) {
		return XST_FAILURE;
	}

	Status = XScuGic_CfgInitialize(IntcInstancePtr, IntcConfig,
					IntcConfig->CpuBaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	 //Connect the interrupt controller interrupt handler to the
	 //hardware interrupt handling logic in the processor.

	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
				(Xil_ExceptionHandler) XScuGic_InterruptHandler,
				IntcInstancePtr);

	/*
	 * Connect a device driver handler that will be called when an
	 * interrupt for the device occurs, the device driver handler
	 * performs the specific interrupt processing for the device
	 */
	Status = XScuGic_Connect(IntcInstancePtr, UartIntrId,
				  (Xil_ExceptionHandler) XUartPs_InterruptHandler,
				  (void *) UartInstancePtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/* Enable the interrupt for the device */
	XScuGic_Enable(IntcInstancePtr, UartIntrId);

	/* Enable interrupts */


	return XST_SUCCESS;
}
